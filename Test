#define NUM_SENSORS 6

// Sensor pins
const int sensorPins[NUM_SENSORS] = {A0, A1, A2, A3, A6, A7};
int sensorValues[NUM_SENSORS];

// Motor pins
const int motorLeftPWM = 5;
const int motorRightPWM = 6;
const int motorLeftDir1 = 2;
const int motorLeftDir2 = 4;
const int motorRightDir1 = 7;
const int motorRightDir2 = 8;
const int stbyPin = 9;

// Proportional control parameter
double Kp = 0.2;
double setpoint = 2500; // Center value for 6 sensors

void setup() {
  // Initialize motors
  pinMode(motorLeftPWM, OUTPUT);
  pinMode(motorRightPWM, OUTPUT);
  pinMode(motorLeftDir1, OUTPUT);
  pinMode(motorLeftDir2, OUTPUT);
  pinMode(motorRightDir1, OUTPUT);
  pinMode(motorRightDir2, OUTPUT);
  pinMode(stbyPin, OUTPUT);
  digitalWrite(stbyPin, HIGH); // Enable motor driver
}

void loop() {
  // Read sensor values
  int position = readSensors();

  // Calculate error
  double error = setpoint - position;

  // Compute control output
  double output = Kp * error;

  // Set motor speeds
  int motorSpeed = 200; // Base speed
  int leftSpeed = motorSpeed + output;
  int rightSpeed = motorSpeed - output;

  // Ensure motor speeds are within bounds
  leftSpeed = constrain(leftSpeed, -255, 255);
  rightSpeed = constrain(rightSpeed, -255, 255);

  // Set motor directions
  if (leftSpeed > 0) {
    digitalWrite(motorLeftDir1, HIGH);
    digitalWrite(motorLeftDir2, LOW);
  } else {
    digitalWrite(motorLeftDir1, LOW);
    digitalWrite(motorLeftDir2, HIGH);
    leftSpeed = -leftSpeed;
  }

  if (rightSpeed > 0) {
    digitalWrite(motorRightDir1, HIGH);
    digitalWrite(motorRightDir2, LOW);
  } else {
    digitalWrite(motorRightDir1, LOW);
    digitalWrite(motorRightDir2, HIGH);
    rightSpeed = -rightSpeed;
  }

  // Set motor speeds
  analogWrite(motorLeftPWM, leftSpeed);
  analogWrite(motorRightPWM, rightSpeed);
}

int readSensors() {
  int position = 0;
  int total = 0;
  for (int i = 0; i < NUM_SENSORS; i++) {
    sensorValues[i] = analogRead(sensorPins[i]);
    sensorValues[i] = 1023 - sensorValues[i]; // Invert sensor values for white line
    position += sensorValues[i] * (i * 1000); // Weighted sum
    total += sensorValues[i];
  }
  return total > 0 ? position / total : 2500; // Return average position
}
